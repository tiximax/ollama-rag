"""
Circuit Breaker Pattern Implementation
=======================================
Circuit Breaker si√™u th√¥ng minh nh∆∞ si√™u anh h√πng b·∫£o v·ªá h·ªá th·ªëng! ü¶∏‚Äç‚ôÇÔ∏è

Prevents cascade failures b·∫±ng c√°ch:
1. Tracking failures v√† t·ª± ƒë·ªông m·ªü circuit khi qu√° ng∆∞·ª°ng
2. Timeout ƒë·ªÉ circuit t·ª± ƒë·ªông th·ª≠ l·∫°i (half-open state)
3. Graceful degradation thay v√¨ crash to√†n h·ªá th·ªëng

States:
- CLOSED: Normal operation, requests pass through
- OPEN: Circuit tripped, requests fail fast
- HALF_OPEN: Testing if service recovered

·ªîn ƒë·ªãnh nh∆∞ kim c∆∞∆°ng! üíé
"""

import logging
import threading
import time
from collections import deque
from collections.abc import Callable
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any, TypeVar

# Import metrics helpers - monitoring nh∆∞ si√™u anh h√πng! ü¶∏‚Äç‚ôÇÔ∏è
try:
    from app import metrics

    METRICS_ENABLED = True
except ImportError:
    METRICS_ENABLED = False

logger = logging.getLogger(__name__)

T = TypeVar("T")


class CircuitState(Enum):
    """Circuit Breaker states - r√µ r√†ng nh∆∞ ban ng√†y! ‚òÄÔ∏è"""

    CLOSED = "closed"  # Normal: requests pass through
    OPEN = "open"  # Circuit tripped: fail fast
    HALF_OPEN = "half_open"  # Testing recovery


@dataclass
class CircuitBreakerConfig:
    """
    Circuit Breaker configuration - c·∫•u h√¨nh nh∆∞ c√¥ng th·ª©c v√†ng! üìä

    Attributes:
        failure_threshold: S·ªë l·ªói li√™n ti·∫øp tr∆∞·ªõc khi m·ªü circuit
        timeout: Th·ªùi gian (seconds) gi·ªØ circuit OPEN tr∆∞·ªõc khi th·ª≠ HALF_OPEN
        success_threshold: S·ªë success c·∫ßn trong HALF_OPEN ƒë·ªÉ ƒë√≥ng circuit
        window_size: K√≠ch th∆∞·ªõc window tracking failures (sliding window)
        half_open_max_calls: S·ªë calls t·ªëi ƒëa cho ph√©p trong HALF_OPEN state
    """

    failure_threshold: int = 5
    timeout: float = 60.0  # seconds
    success_threshold: int = 2
    window_size: int = 10
    half_open_max_calls: int = 3  # Allow multiple test calls in HALF_OPEN


@dataclass
class CircuitBreakerStats:
    """Statistics tracking - metrics nh∆∞ rockstar! üé∏"""

    total_calls: int = 0
    success_calls: int = 0
    failure_calls: int = 0
    consecutive_failures: int = 0
    consecutive_successes: int = 0
    last_failure_time: float | None = None
    last_success_time: float | None = None
    state_transitions: int = 0


class CircuitBreakerError(Exception):
    """Exception khi circuit OPEN - th√¥ng b√°o r√µ r√†ng! üö®"""

    def __init__(self, message: str, stats: CircuitBreakerStats | None = None):
        super().__init__(message)
        self.stats = stats


class CircuitBreaker:
    """
    Circuit Breaker implementation - b·∫£o v·ªá nh∆∞ si√™u anh h√πng! ü¶∏‚Äç‚ôÇÔ∏è

    S·ª≠ d·ª•ng sliding window ƒë·ªÉ track failures v√† t·ª± ƒë·ªông m·ªü/ƒë√≥ng circuit
    d·ª±a tr√™n thresholds. Thread-safe cho concurrent requests!

    Example:
        >>> breaker = CircuitBreaker(name="ollama", failure_threshold=5)
        >>> @breaker.protect
        ... def call_api():
        ...     return requests.get("http://api.example.com")
        >>> result = call_api()  # Protected by circuit breaker!
    """

    def __init__(
        self,
        name: str,
        config: CircuitBreakerConfig | None = None,
        on_state_change: Callable[[CircuitState, CircuitState], None] | None = None,
    ):
        """
        Kh·ªüi t·∫°o Circuit Breaker - ·ªïn ƒë·ªãnh nh∆∞ kim c∆∞∆°ng! üíé

        Args:
            name: T√™n circuit breaker (for logging/metrics)
            config: Configuration object (s·ª≠ d·ª•ng defaults n·∫øu None)
            on_state_change: Optional callback khi state thay ƒë·ªïi
        """
        self.name = name
        self.config = config or CircuitBreakerConfig()
        self.on_state_change = on_state_change

        # State management - thread-safe v·ªõi lock! üîí
        self._state = CircuitState.CLOSED
        self._lock = threading.RLock()  # Reentrant lock cho nested calls

        # Failure tracking v·ªõi sliding window
        self._failure_window: deque[float] = deque(maxlen=self.config.window_size)

        # Statistics tracking
        self._stats = CircuitBreakerStats()

        # State transition tracking
        self._opened_at: float | None = None
        self._half_open_calls: int = 0

        logger.info(
            f"üîå Circuit Breaker '{name}' initialized: "
            f"failure_threshold={self.config.failure_threshold}, "
            f"timeout={self.config.timeout}s"
        )

    @property
    def state(self) -> CircuitState:
        """Get current state - thread-safe! üîí"""
        with self._lock:
            return self._state

    @property
    def stats(self) -> CircuitBreakerStats:
        """Get current statistics - snapshot nh∆∞ ·∫£nh! üì∏"""
        with self._lock:
            return CircuitBreakerStats(
                total_calls=self._stats.total_calls,
                success_calls=self._stats.success_calls,
                failure_calls=self._stats.failure_calls,
                consecutive_failures=self._stats.consecutive_failures,
                consecutive_successes=self._stats.consecutive_successes,
                last_failure_time=self._stats.last_failure_time,
                last_success_time=self._stats.last_success_time,
                state_transitions=self._stats.state_transitions,
            )

    def _transition_to(self, new_state: CircuitState):
        """
        Chuy·ªÉn state - tracking nh∆∞ pro! üéØ

        Thread-safe state transition v·ªõi logging v√† callback.
        """
        old_state = self._state
        if old_state == new_state:
            return

        self._state = new_state
        self._stats.state_transitions += 1

        # Update Prometheus metrics - real-time monitoring! üìä
        if METRICS_ENABLED:
            try:
                metrics.record_circuit_breaker_transition(
                    breaker_name=self.name, from_state=old_state.value, to_state=new_state.value
                )
                metrics.update_circuit_breaker_state(breaker_name=self.name, state=new_state.value)
            except Exception as e:
                logger.debug(f"Metrics update failed (non-critical): {e}")

        # Update state-specific tracking
        if new_state == CircuitState.OPEN:
            self._opened_at = time.time()
            self._half_open_calls = 0
            logger.warning(
                f"üî¥ Circuit '{self.name}' OPENED after "
                f"{self._stats.consecutive_failures} consecutive failures"
            )
        elif new_state == CircuitState.HALF_OPEN:
            self._half_open_calls = 0
            logger.info(f"üü° Circuit '{self.name}' entering HALF_OPEN (testing recovery)")
        elif new_state == CircuitState.CLOSED:
            self._opened_at = None
            self._failure_window.clear()
            logger.info(f"üü¢ Circuit '{self.name}' CLOSED (recovered)")

        # Callback notification
        if self.on_state_change:
            try:
                self.on_state_change(old_state, new_state)
            except Exception as e:
                logger.error(f"Error in state change callback: {e}")

    def _check_and_update_state(self):
        """
        Ki·ªÉm tra v√† update state d·ª±a tr√™n conditions - logic nh∆∞ v√†ng! üèÜ

        Called before m·ªói request ƒë·ªÉ x√°c ƒë·ªãnh xem circuit c√≥ m·ªü/ƒë√≥ng kh√¥ng.
        """
        current_time = time.time()

        if self._state == CircuitState.OPEN:
            # Check if timeout expired ‚Üí transition to HALF_OPEN
            if (
                self._opened_at is not None
                and current_time - self._opened_at >= self.config.timeout
            ):
                self._transition_to(CircuitState.HALF_OPEN)

    def _record_success(self):
        """
        Ghi nh·∫≠n success - tracking nh∆∞ si√™u sao! ‚≠ê

        Updates stats v√† state transitions d·ª±a tr√™n consecutive successes.
        """
        with self._lock:
            self._stats.total_calls += 1
            self._stats.success_calls += 1
            self._stats.consecutive_successes += 1
            self._stats.consecutive_failures = 0
            self._stats.last_success_time = time.time()

            # Update Prometheus metrics - success tracking! ‚úÖ
            if METRICS_ENABLED:
                try:
                    metrics.record_circuit_breaker_call(breaker_name=self.name, status='success')
                    metrics.update_circuit_breaker_failures(
                        breaker_name=self.name, consecutive_failures=0
                    )
                except Exception as e:
                    logger.debug(f"Metrics update failed (non-critical): {e}")

            if self._state == CircuitState.HALF_OPEN:
                # Success in HALF_OPEN ‚Üí check if can close
                if self._stats.consecutive_successes >= self.config.success_threshold:
                    self._transition_to(CircuitState.CLOSED)

    def _record_failure(self):
        """
        Ghi nh·∫≠n failure - tracking ch√≠nh x√°c! üéØ

        Updates failure window v√† checks n·∫øu c·∫ßn open circuit.
        """
        with self._lock:
            current_time = time.time()
            self._stats.total_calls += 1
            self._stats.failure_calls += 1
            self._stats.consecutive_failures += 1
            self._stats.consecutive_successes = 0
            self._stats.last_failure_time = current_time

            # Update Prometheus metrics - failure tracking! ‚ùå
            if METRICS_ENABLED:
                try:
                    metrics.record_circuit_breaker_call(breaker_name=self.name, status='failure')
                    metrics.update_circuit_breaker_failures(
                        breaker_name=self.name,
                        consecutive_failures=self._stats.consecutive_failures,
                    )
                except Exception as e:
                    logger.debug(f"Metrics update failed (non-critical): {e}")

            # Add to sliding window
            self._failure_window.append(current_time)

            if self._state == CircuitState.HALF_OPEN:
                # Failure in HALF_OPEN ‚Üí reopen circuit immediately
                self._transition_to(CircuitState.OPEN)
            elif self._state == CircuitState.CLOSED:
                # Check if should open based on consecutive failures
                if self._stats.consecutive_failures >= self.config.failure_threshold:
                    self._transition_to(CircuitState.OPEN)

    def call(self, func: Callable[..., T], *args: Any, **kwargs: Any) -> T:
        """
        Execute function v·ªõi circuit breaker protection - an to√†n tuy·ªát ƒë·ªëi! üõ°Ô∏è

        Args:
            func: Function to execute
            *args: Positional arguments cho func
            **kwargs: Keyword arguments cho func

        Returns:
            Result t·ª´ func n·∫øu success

        Raises:
            CircuitBreakerError: N·∫øu circuit OPEN
            Exception: Original exception t·ª´ func n·∫øu call fails
        """
        with self._lock:
            self._check_and_update_state()

            # Check if circuit is open
            if self._state == CircuitState.OPEN:
                # Record rejected call in metrics üö´
                if METRICS_ENABLED:
                    try:
                        metrics.record_circuit_breaker_call(
                            breaker_name=self.name, status='rejected'
                        )
                    except Exception:
                        pass
                raise CircuitBreakerError(
                    f"Circuit '{self.name}' is OPEN (will retry after timeout)",
                    stats=self.stats,
                )

            # Check half-open call limit
            if self._state == CircuitState.HALF_OPEN:
                if self._half_open_calls >= self.config.half_open_max_calls:
                    # Record rejected call in metrics üö´
                    if METRICS_ENABLED:
                        try:
                            metrics.record_circuit_breaker_call(
                                breaker_name=self.name, status='rejected'
                            )
                        except Exception:
                            pass
                    raise CircuitBreakerError(
                        f"Circuit '{self.name}' is HALF_OPEN and max calls reached",
                        stats=self.stats,
                    )
                self._half_open_calls += 1

        # Execute function (outside lock ƒë·ªÉ tr√°nh block other threads!)
        try:
            result = func(*args, **kwargs)
            self._record_success()
            return result
        except Exception as e:
            self._record_failure()
            logger.error(f"‚ùå Circuit '{self.name}' call failed: {type(e).__name__}: {e}")
            raise

    def protect(self, func: Callable[..., T]) -> Callable[..., T]:
        """
        Decorator ƒë·ªÉ wrap function v·ªõi circuit breaker - d·ªÖ d√†ng nh∆∞ ƒÉn k·∫πo! üç¨

        Example:
            >>> breaker = CircuitBreaker(name="api")
            >>> @breaker.protect
            ... def call_api():
            ...     return requests.get("http://api.example.com")
        """

        def wrapper(*args, **kwargs) -> T:
            return self.call(func, *args, **kwargs)

        wrapper.__name__ = func.__name__
        wrapper.__doc__ = func.__doc__
        return wrapper

    def reset(self):
        """
        Reset circuit breaker v·ªÅ initial state - fresh start! üîÑ

        Useful for testing ho·∫∑c manual recovery.
        """
        with self._lock:
            old_state = self._state
            self._state = CircuitState.CLOSED
            self._opened_at = None
            self._failure_window.clear()
            self._half_open_calls = 0
            self._stats = CircuitBreakerStats()
            logger.info(f"üîÑ Circuit '{self.name}' reset (was {old_state.value})")

    def get_metrics(self) -> dict[str, Any]:
        """
        Get metrics dictionary - perfect cho monitoring! üìä

        Returns:
            Dict v·ªõi all metrics v√† state info
        """
        with self._lock:
            return {
                "name": self.name,
                "state": self._state.value,
                "total_calls": self._stats.total_calls,
                "success_calls": self._stats.success_calls,
                "failure_calls": self._stats.failure_calls,
                "consecutive_failures": self._stats.consecutive_failures,
                "consecutive_successes": self._stats.consecutive_successes,
                "error_rate_percent": (
                    (self._stats.failure_calls / self._stats.total_calls * 100)
                    if self._stats.total_calls > 0
                    else 0.0
                ),
                "success_rate_percent": (
                    (self._stats.success_calls / self._stats.total_calls * 100)
                    if self._stats.total_calls > 0
                    else 0.0
                ),
                "state_transitions": self._stats.state_transitions,
                "last_failure_time": (
                    datetime.fromtimestamp(self._stats.last_failure_time).isoformat()
                    if self._stats.last_failure_time
                    else None
                ),
                "last_success_time": (
                    datetime.fromtimestamp(self._stats.last_success_time).isoformat()
                    if self._stats.last_success_time
                    else None
                ),
                "config": {
                    "failure_threshold": self.config.failure_threshold,
                    "timeout": self.config.timeout,
                    "success_threshold": self.config.success_threshold,
                    "window_size": self.config.window_size,
                },
            }

    def __repr__(self) -> str:
        """String representation - debug nh∆∞ pro! üîç"""
        return (
            f"CircuitBreaker(name='{self.name}', state={self._state.value}, "
            f"failures={self._stats.consecutive_failures})"
        )
